# Design Pattern Cheat Sheet

---

## **Creational Design Patterns**

| **Pattern**         | **Description**                                                                                                                                                                                                                              | **When to Use**                                                                                                                                                                                             | **Example Code**                                                                                                               |
|----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------|
| **Singleton**       | Ensures that a class has only one instance and provides a global point of access to it.                                                                                                                                                     | When a single instance of a class is needed across the system (e.g., a configuration manager or logging service).                                                                                          | class Singleton:     <br>    _instance = None <br>    @staticmethod <br>    def get_instance(): <br>        if Singleton._instance is None: <br>            Singleton._instance = Singleton() <br>        return Singleton._instance |
| **Factory Method**  | Defines an interface for creating objects but allows subclasses to alter the type of objects that will be created.                                                                                                                         | When the client code doesn't need to know the exact class of objects to create.                                                                                                                            | class Factory: <br>    def create_object(self, type): <br>        if type == "A": return A() <br>        elif type == "B": return B()                                    |
| **Abstract Factory**| Provides an interface to create families of related or dependent objects without specifying their concrete classes.                                                                                                                        | When you need to ensure consistency among objects of a related family.                                                                                                                                     | class WidgetFactory: <br>    def create_button(self): <br>        pass <br>class WindowsFactory(WidgetFactory): <br>    def create_button(self): <br>        return WindowsButton() |
| **Builder**         | Separates the construction of a complex object from its representation so that the same construction process can create different representations.                                                                                         | When creating complex objects that require multiple steps and configurations.                                                                                                                              | class Builder: <br>    def build_part_a(self): pass <br>    def build_part_b(self): pass <br>class Director: <br>    def construct(self, builder): <br>        builder.build_part_a() <br>        builder.build_part_b() |
| **Prototype**       | Specifies the kinds of objects to create using a prototypical instance and creates new objects by copying this prototype.                                                                                                                  | When creating objects that are expensive to instantiate, and you want to clone them instead.                                                                                                               | import copy <br>class Prototype: <br>    def clone(self): <br>        return copy.deepcopy(self)                                                                          |

---

## **Structural Design Patterns**

| **Pattern**         | **Description**                                                                                                                                                                                                                              | **When to Use**                                                                                                                                                                                             | **Example Code**                                                                                                               |
|----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------|
| **Adapter**         | Allows incompatible interfaces to work together by providing a bridge between them.                                                                                                                                                         | When you want to use an existing class but its interface is not compatible with your code.                                                                                                                 | class Adapter: <br>    def __init__(self, adaptee): <br>        self.adaptee = adaptee <br>    def request(self): <br>        return self.adaptee.specific_request()        |
| **Bridge**          | Decouples an abstraction from its implementation so that the two can vary independently.                                                                                                                                                    | When both abstraction and implementation may change independently.                                                                                                                                         | class Abstraction: <br>    def __init__(self, implementor): <br>        self.implementor = implementor                                                                 |
| **Composite**       | Composes objects into tree structures to represent part-whole hierarchies.                                                                                                                                                                  | When you need to represent a tree structure and treat individual objects and compositions of objects uniformly.                                                                                            | class Component: <br>    def operation(self): pass <br>class Composite(Component): <br>    def add(self, component): pass <br>    def operation(self): <br>        for c in self.children: <br>            c.operation() |
| **Decorator**       | Adds behavior to objects dynamically without modifying their code.                                                                                                                                                                         | When you want to add responsibilities to individual objects, not to the entire class.                                                                                                                      | class Decorator: <br>    def __init__(self, component): <br>        self.component = component <br>    def operation(self): <br>        return f"Decorated {self.component.operation()}" |
| **Facade**          | Provides a simplified interface to a larger body of code, making it easier to use.                                                                                                                                                         | When you need to provide a simple interface to a complex subsystem.                                                                                                                                         | class Facade: <br>    def operation(self): <br>        return f"{self.subsystem1.operation()} {self.subsystem2.operation()}"                                           |

---

## **Behavioral Design Patterns**

| **Pattern**         | **Description**                                                                                                                                                                                                                              | **When to Use**                                                                                                                                                                                             | **Example Code**                                                                                                               |
|----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------|
| **Observer**        | Defines a one-to-many dependency so that when one object changes state, all its dependents are notified and updated automatically.                                                                                                           | When an object needs to notify multiple observers about its state changes.                                                                                                                                  | class Observer: <br>    def update(self, subject): pass <br>class Subject: <br>    def notify(self): <br>        for obs in self.observers: <br>            obs.update(self) |
| **Strategy**        | Defines a family of algorithms, encapsulates each one, and makes them interchangeable.                                                                                                                                                       | When you want to define multiple algorithms and let the client choose which one to use.                                                                                                                     | class Strategy: <br>    def execute(self): pass <br>class Context: <br>    def __init__(self, strategy): <br>        self.strategy = strategy                               |
| **State**           | Allows an object to alter its behavior when its internal state changes.                                                                                                                                                                     | When an object’s behavior depends on its state, and it must change behavior dynamically at runtime.                                                                                                         | class State: <br>    def handle(self): pass <br>class Context: <br>    def set_state(self, state): <br>        self.state = state                                           |
| **Command**         | Encapsulates a request as an object, thereby allowing users to parameterize clients with different requests, queue requests, or log requests.                                                                                                | When you need to parameterize objects with operations or delay the execution of a request.                                                                                                                  | class Command: <br>    def execute(self): pass <br>class Invoker: <br>    def set_command(self, cmd): <br>        self.cmd = cmd <br>    def run(self): <br>        self.cmd.execute() |
| **Chain of Responsibility** | Lets you pass requests along a chain of handlers, where each handler decides whether to handle the request or pass it to the next handler in the chain.                                                                                  | When more than one object may handle a request, and the handler isn’t known in advance.                                                                                                                     | class Handler: <br>    def set_next(self, handler): <br>        self.next = handler <br>    def handle(self, request): <br>        if self.next: <br>            self.next.handle(request) |
